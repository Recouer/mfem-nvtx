[1mdiff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp[m
[1mindex 385046f85..9984d905f 100644[m
[1m--- a/fem/bilinearform.cpp[m
[1m+++ b/fem/bilinearform.cpp[m
[36m@@ -647,7 +647,7 @@[m [mnamespace mfem {[m
 #endif[m
     }[m
 [m
[31m-    void BilinearForm::Assemble(int skip_zeros) {[m
[32m+[m[32m    void BilinearForm::Assemble(int skip_zeros, int gpu_assembly=0) {[m
 #ifdef MFEM_USE_CUDA[m
         char str_nvtx[256];[m
 	sprintf(str_nvtx, "%d ", __LINE__);[m
[36m@@ -873,6 +873,8 @@[m [mnamespace mfem {[m
 #endif[m
     }[m
 [m
[32m+[m
[32m+[m
     void BilinearForm::ConformingAssemble() {[m
 #ifdef MFEM_USE_CUDA[m
         char str_nvtx[256];[m
[1mdiff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp[m
[1mindex 7b3d41e90..38ecdd32c 100644[m
[1m--- a/fem/bilininteg.cpp[m
[1m+++ b/fem/bilininteg.cpp[m
[36m@@ -11,6 +11,7 @@[m
 [m
 // Implementation of Bilinear Form Integrators[m
 [m
[32m+[m[32m#include "../general/forall.hpp"[m
 #include "fem.hpp"[m
 #include <cmath>[m
 #include <algorithm>[m
[36m@@ -3909,9 +3910,11 @@[m [mvoid ElasticityIntegrator::AssembleElementMatrix([m
 	strcat(str, " ");[m
 	strcat(str, __FUNCTION__);[m
 	nvtxRangePush(str);[m
[32m+[m	[32mnvtxRangePush("Initialisation");[m
 	[m
 #endif[m
 [m
[32m+[m
    int dof = el.GetDof();[m
    int dim = el.GetDim();[m
    double w, L, M;[m
[36m@@ -3933,61 +3936,119 @@[m [mvoid ElasticityIntegrator::AssembleElementMatrix([m
    const IntegrationRule *ir = IntRule;[m
    if (ir == NULL)[m
    {[m
[31m-   int order = 2 * Trans.OrderGrad(&el); // correct order?[m
[31m-   ir = &IntRules.Get(el.GetGeomType(), order);[m
[32m+[m[32m      int order = 2 * Trans.OrderGrad(&el); // correct order?[m
[32m+[m[32m      ir = &IntRules.Get(el.GetGeomType(), order);[m
    }[m
 [m
    elmat = 0.0;[m
 [m
[31m-   for (int i = 0; i < ir -> GetNPoints(); i++)[m
[31m-   {[m
[31m-   const IntegrationPoint &ip = ir->IntPoint(i);[m
[31m-[m
[31m-   el.CalcDShape(ip, dshape);[m
[31m-[m
[31m-   Trans.SetIntPoint(&ip);[m
[31m-   w = ip.weight * Trans.Weight();[m
[31m-   Mult(dshape, Trans.InverseJacobian(), gshape);[m
[31m-   MultAAt(gshape, pelmat);[m
[31m-   gshape.GradToDiv (divshape);[m
[32m+[m[32m#ifdef MFEM_USE_CUDA[m
[32m+[m[32m   nvtxRangePop();[m
[32m+[m[32m#endif[m
 [m
[31m-   M = mu->Eval(Trans, ip);[m
[31m-   if (lambda)[m
[31m-   {[m
[31m-    L = lambda->Eval(Trans, ip);[m
[31m-   }[m
[31m-   else[m
[32m+[m[32m   for (int i = 0; i < ir -> GetNPoints(); i++)[m
    {[m
[31m-    L = q_lambda * M;[m
[31m-    M = q_mu * M;[m
[31m-   }[m
[32m+[m[32m      const IntegrationPoint &ip = ir->IntPoint(i);[m
[32m+[m
[32m+[m[32m      el.CalcDShape(ip, dshape);[m
[32m+[m
[32m+[m[32m      Trans.SetIntPoint(&ip);[m
[32m+[m[32m      // ???[m
[32m+[m
[32m+[m[32m      w = ip.weight * Trans.Weight();[m
[32m+[m[32m      Mult(dshape, Trans.InverseJacobian(), gshape);[m
[32m+[m[32m      // kernels::Mult(ah,aw,bw,bd,cd,ad);[m
[32m+[m
[32m+[m
[32m+[m[32m      MultAAt(gshape, pelmat);[m
[32m+[m[32m      /*[m
[32m+[m[32m         const int height = gshape.Height();[m
[32m+[m[32m         const int width = gshape.Width();[m
[32m+[m[32m         for (int i = 0; i < height; i++)[m
[32m+[m[32m         {[m
[32m+[m[32m            for (int j = 0; j <= i; j++)[m
[32m+[m[32m            {[m
[32m+[m[32m               double temp = 0.;[m
[32m+[m[32m               for (int k = 0; k < width; k++)[m
[32m+[m[32m               {[m
[32m+[m[32m                  temp += a(i,k) * a(j,k);[m
[32m+[m[32m               }[m
[32m+[m[32m               aat(j,i) = aat(i,j) = temp;[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m      */[m
[32m+[m
[32m+[m[32m      gshape.GradToDiv (divshape);[m[41m [m
[32m+[m[32m      // divshape[i] = gshape[i] for i in dim*dof[m
[32m+[m
[32m+[m[32m      M = mu->Eval(Trans, ip);[m
[32m+[m[32m      if (lambda)[m
[32m+[m[32m      {[m
[32m+[m[32m         L = lambda->Eval(Trans, ip);[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m         L = q_lambda * M;[m
[32m+[m[32m         M = q_mu * M;[m
[32m+[m[32m      }[m
 [m
[31m-   if (L != 0.0)[m
[31m-   {[m
[31m-    AddMult_a_VVt(L * w, divshape, elmat);[m
[31m-   }[m
[32m+[m[32m      auto GPU_elmat = Reshape(elmat.ReadWrite(), dof, dim);[m
[32m+[m[32m      auto GPU_pelmat = Reshape(pelmat.Read(), dof, dim);[m
[32m+[m[32m      auto GPU_divshape = Reshape(divshape.Read(), dim*dof, 1);[m
[32m+[m[32m      auto GPU_gshape = Reshape(gshape.Read(), dof, dim);[m
 [m
[31m-   if (M != 0.0)[m
[31m-   {[m
[31m-    for (int d = 0; d < dim; d++)[m
[31m-    {[m
[31m-    for (int k = 0; k < dof; k++)[m
[31m-     for (int l = 0; l < dof; l++)[m
[31m-     {[m
[31m-      elmat (dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);[m
[31m-     }[m
[31m-    }[m
[31m-    for (int ii = 0; ii < dim; ii++)[m
[31m-    for (int jj = 0; jj < dim; jj++)[m
[31m-    {[m
[31m-     for (int kk = 0; kk < dof; kk++)[m
[31m-      for (int ll = 0; ll < dof; ll++)[m
[32m+[m[32m      auto device_kernel = [=] MFEM_DEVICE (int)[m
       {[m
[31m-       elmat(dof*ii+kk, dof*jj+ll) +=[m
[31m-       (M * w) * gshape(kk, jj) * gshape(ll, ii);[m
[32m+[m[32m         if (L != 0.0)[m
[32m+[m[32m         {[m
[32m+[m[32m            MFEM_ASSERT(elmat.Height() == v.Size() && elmat.Width() == v.Size(),[m
[32m+[m[32m                        "incompatible dimensions!");[m
[32m+[m[41m            [m
[32m+[m[32m            MFEM_SHARED double a = L * w;[m
[32m+[m[32m            MFEM_SHARED const int n = divshape.Size();[m
[32m+[m[41m            [m
[32m+[m[32m            MFEM_FOREACH_THREAD(i, x, n)[m
[32m+[m[32m            {[m
[32m+[m[32m               double avi = a * GPU_divshape(i);[m
[32m+[m[32m               MFEM_FOREACH_THREAD(j, y, i)[m
[32m+[m[32m               {[m
[32m+[m[32m                  const double avivj = avi * GPU_divshape(j);[m
[32m+[m[32m                  GPU_elmat(i, j) += avivj;[m
[32m+[m[32m                  GPU_elmat(j, i) += avivj;[m
[32m+[m[32m               }[m
[32m+[m[32m               GPU_elmat(i, i) += avi * GPU_divshape(i);[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         if (M != 0.0)[m
[32m+[m[32m         {[m
[32m+[m[32m            for (int d = 0; d < dim; d++)[m
[32m+[m[32m            {[m
[32m+[m[32m               MFEM_FOREACH_THREAD(k, x, dof)[m
[32m+[m[32m                  MFEM_FOREACH_THREAD(l, y, dof)[m
[32m+[m[32m                  {[m
[32m+[m[32m                     GPU_elmat (dof*d+k, dof*d+l) += (M * w) * GPU_pelmat(k, l);[m
[32m+[m[32m                  }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            for (int ii = 0; ii < dim; ii++)[m
[32m+[m[32m               for (int jj = 0; jj < dim; jj++)[m
[32m+[m[32m               {[m
[32m+[m[32m                  MFEM_FOREACH_THREAD(kk, x, dof)[m
[32m+[m[32m                     MFEM_FOREACH_THREAD(ll, y, dof)[m
[32m+[m[32m                     {[m
[32m+[m[32m                        GPU_elmat(dof*ii+kk, dof*jj+ll) +=[m
[32m+[m[32m                        (M * w) * GPU_gshape(kk, jj) * GPU_gshape(ll, ii);[m
[32m+[m[32m                     }[m
[32m+[m[32m               }[m
[32m+[m[32m         }[m
       }[m
[31m-    }[m
[31m-   }[m
[32m+[m
[32m+[m[32m      auto host_kernel = [&] MFEM_LAMBDA (int) {[m
[32m+[m[32m         printf("this is done on the host\n");[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      ForallWrap<1>(true, 1, device_kernel, host_kernel, 1);[m
    }[m
 [m
 #ifdef MFEM_USE_CUDA[m
[1mdiff --git a/fem/pbilinearform.cpp b/fem/pbilinearform.cpp[m
[1mindex ee1030c48..7c3bb48f7 100644[m
[1m--- a/fem/pbilinearform.cpp[m
[1m+++ b/fem/pbilinearform.cpp[m
[36m@@ -262,6 +262,29 @@[m [mvoid ParBilinearForm::AssembleSharedFaces(int skip_zeros)[m
    }[m
 }[m
 [m
[32m+[m[32m#ifdef MFEM_USE_CUDA[m
[32m+[m
[32m+[m[32mvoid ParBilinearForm::Assemble(int skip_zeros, int gpu_assembly=0)[m
[32m+[m[32m{[m
[32m+[m[32m   if (interior_face_integs.Size())[m
[32m+[m[32m   {[m
[32m+[m[32m      pfes->ExchangeFaceNbrData();[m
[32m+[m[32m      if (!ext && mat == NULL)[m
[32m+[m[32m      {[m
[32m+[m[32m         pAllocMat();[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   BilinearForm::Assemble(skip_zeros, gpu_assembly);[m
[32m+[m
[32m+[m[32m   if (!ext && interior_face_integs.Size() > 0)[m
[32m+[m[32m   {[m
[32m+[m[32m      AssembleSharedFaces(skip_zeros);[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#else[m
[32m+[m
 void ParBilinearForm::Assemble(int skip_zeros)[m
 {[m
    if (interior_face_integs.Size())[m
[36m@@ -273,7 +296,7 @@[m [mvoid ParBilinearForm::Assemble(int skip_zeros)[m
       }[m
    }[m
 [m
[31m-   BilinearForm::Assemble(skip_zeros);[m
[32m+[m[32m   BilinearForm::Assemble(skip_zeros, gpu_assembly);[m
 [m
    if (!ext && interior_face_integs.Size() > 0)[m
    {[m
[36m@@ -281,6 +304,8 @@[m [mvoid ParBilinearForm::Assemble(int skip_zeros)[m
    }[m
 }[m
 [m
[32m+[m[32m#endif[m
[32m+[m
 void ParBilinearForm::AssembleDiagonal(Vector &diag) const[m
 {[m
    MFEM_ASSERT(diag.Size() == fes->GetTrueVSize(),[m
[1mdiff --git a/general/forall.hpp b/general/forall.hpp[m
[1mindex baa2d7129..5a0bd02b7 100644[m
[1m--- a/general/forall.hpp[m
[1m+++ b/general/forall.hpp[m
[36m@@ -75,7 +75,7 @@[m [mconst int MAX_Q1D = 14;[m
 #define MFEM_FORALL_3D(i,N,X,Y,Z,...)                    \[m
    ForallWrap<3>(true,N,                                 \[m
                  [=] MFEM_DEVICE (int i) {__VA_ARGS__},  \[m
[31m-                 [&] MFEM_LAMBDA (int i) {__VA_ARGS__},\[m
[32m+[m[32m                 [&] MFEM_LAMBDA (int i) {__VA_ARGS__},  \[m
                  X,Y,Z)[m
 [m
 // MFEM_FORALL with a 3D CUDA block and grid[m
[36m@@ -83,7 +83,7 @@[m [mconst int MAX_Q1D = 14;[m
 #define MFEM_FORALL_3D_GRID(i,N,X,Y,Z,G,...)             \[m
    ForallWrap<3>(true,N,                                 \[m
                  [=] MFEM_DEVICE (int i) {__VA_ARGS__},  \[m
[31m-                 [&] MFEM_LAMBDA (int i) {__VA_ARGS__},\[m
[32m+[m[32m                 [&] MFEM_LAMBDA (int i) {__VA_ARGS__},  \[m
                  X,Y,Z,G)[m
 [m
 // MFEM_FORALL that uses the basic CPU backend when use_dev is false. See for[m
